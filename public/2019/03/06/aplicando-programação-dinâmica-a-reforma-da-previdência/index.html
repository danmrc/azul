<!DOCTYPE html>
<html lang="pt-br">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="Daniel Coutinho e Pedro Cavalcante">
		<meta name="description" content="Economia, Estatística, Programação">
		<meta name="generator" content="Hugo 0.48" />
		<title>Aplicando Programação Dinâmica a Reforma da Previdência &middot; AZUL</title>
		<link rel="shortcut icon" href="/images/favicon.ico">
		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/highlight.css">

		
		<link rel="stylesheet" href="/css/monosocialiconsfont.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='/'> <span class="arrow">←</span>Início</a>
	
	<a href='/post'>Arquivo</a>
	<a href='/tags'>Tags</a>
	<a href='/about'>Sobre</a>
  <a href='/categories'>Categorias</a>
  
	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Aplicando Programação Dinâmica a Reforma da Previdência
                    </h1>
                    <h2 class="headline">
                    Mar 6, 2019 00:00
                    · 1277 words
                    · 6 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="/tags/reforma-da-previd%C3%AAncia">Reforma da Previdência</a>
                          
                              <a href="/tags/modelo-de-ciclo-de-vida">Modelo de Ciclo de Vida</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                
                <section id="post-body">
                    <p>Nós no Azul não discutimos políticas públicas diretamente. Muitos outros sites, com autores competentes, o fazem. É uma simples questão de vantagens comparativas. Mas nós nos contagiamos pelo clima da reforma da previdência, como quase todos os economistas. E a reforma da previdência vem a ser um excelente tema para ser explorado usando programação dinâmica, que eu já tratei aqui no blog em <a href="https://azul.netlify.com/categories/programa%C3%A7%C3%A3o-din%C3%A2mica/">outras ocasiões</a>.</p>
<p>Vamos pensar em um agente que recebe um salário <span class="math inline">\(\omega\)</span> e pode escolher poupar ou consumir. Ele sabe que em uma certa idade ele vai se aposentar e passar a receber uma aposentadoria <span class="math inline">\(s\)</span>. Qual a escolha ótima desse agente? Nós nos fizemos uma pergunta similar em posts anteriores e lá - como aqui - eu vou adotar algumas hipóteses simplificadoras (como de praxe):</p>
<ul>
<li>O salário é um processo i.i.d. (Relaxarei essa em um outro post). Eu vou usar a distribuição Gama(5,1), que tem suporte finito e nos números positivos - como se espera de um salário.</li>
<li>O agente sabe exatamente quanto tempo ele vai viver e exatamente quanto tempo ele vai trabalhar. O primeiro é polêmico, mas ele facilita enormemente as contas e é mais realista do que supor que o agente se planeja para o infinito quando ele pensa na aposentadoria. O segundo é relativamente realístico.</li>
<li>Existe um único ativo que paga uma taxa de juros <span class="math inline">\(r\)</span>.</li>
<li>O agente não pode se endividar. Isso facilita a vida na hora de resolver o problema de otimização (numericamente) e é uma maneira muito fácil de evitar esquemas em que o agente se endivida ao infinito.</li>
</ul>
<p>Então o problema do agente é:</p>
<p><span class="math display">\[Max_{\{c_t\}_{t=0}^T} \displaystyle \sum_{t=0}^T \beta E(u(c_t)) \text{ sujeito a } a_{t+1} = (1+r)a_t + W_t - c_t \]</span></p>
<p>Onde</p>
<p><span class="math display">\[W_t = 
\begin{cases}
\omega_t &amp; \text{se } 0 \geq t \leq T_{aposentadoria}\\
s &amp; \text{se } T_{aposentadoria} \geq t \leq T\\
\end{cases}\]</span></p>
<p>Veja que isso gera uma quebra no nosso problema de programação dinâmica: de um ponto em diante a dotação muda completamente, inclusive deixando de ser aleatória. Vamos resolver isso de uma maneira muito esperta, como sugerida no site do <a href="https://lectures.quantecon.org/jl/lqcontrol.html#Further-Applications">quant.econ</a>:</p>
<ol style="list-style-type: decimal">
<li>Resolva recursivamente o problema do agente aposentado, sabendo que no fim da vida dele o ótimo é gastar todos os ativos. (Como já fizemos)</li>
<li>Use a função Valor do primeiro período do agente aposentado como o valor terminal do problema do agente que trabalha</li>
<li>Resolva recursivamente o problema do agente que trabalha</li>
</ol>
<p>Ou seja, quebramos o problema do agente em dois problemas separados e ressolvemos eles separadamente, com a ligação entre eles feita pela função valor dos dois problemas.</p>
<p>O programa em Julia que resolve o problema segue abaixo. Eu uso w para gerar o grid de riqueza e utilizo a utilidade log. Eu inicialmente coloco um agente trabalhando 65 anos e vivendo 20 anos aposentado, um total de 85 anos. O valor da aposentadoria é 1. A média da distribuição Gama(5,1) é 5, então nossa aposentadoria é bem menor que o que o agente vai ganhar em média durante a vida.</p>
<pre><code>#Carregando os pacotes que precisamos
using Distributions
using Plots
using Interpolations
using Statistics
using Optim

d = Gamma(5,1)
w = range(0.01,stop=300,length=1000)

u(c) = log(c)

bet = 1/(1+r)
work_age = 65
s = 1
ret_age = 20

#Resolvendo o problema do aposentado

choice_ret = zeros(ret_age,length(w))
value_ret = zeros(ret_age,length(w))

value_ret[1,:] = u.(w)
choice_ret[1,:] = w

for j in 2:ret_age
    f = LinearInterpolation(w,value_ret[j-1,:], extrapolation_bc = Line())
    for i in 1:length(w)
        val(c) = -(u(c) + bet*f((1+r)*w[i] -c + s))
        otm = optimize(val,0,w[i])
        choice_ret[j,i] = Optim.minimizer(otm)
        value_ret[j,i] = -Optim.minimum(otm)
    end
    println(&quot;Iteration &quot;, j)
end

#Resolvendo o problema do trabalhador

value_trab = zeros(work_age,length(w))
choice_trab = zeros(work_age,length(w))

value_trab[1,:] = value_ret[ret_age,:] #Colocando a função Valor do aposentado como condição final do problema do trabalhador
choice_trab[1,:] = choice_ret[ret_age,:]

for k in 2:work_age
    f =  LinearInterpolation(w,value_trab[k-1,:], extrapolation_bc = Line())
    for i in 1:length(w)
        mm = rand(d,2000)
        val(c) = -(u(c) + bet*mean(f.((1+r)*w[i] -c .+ mm)))
        otm = optimize(val,0,w[i])
        choice_trab[k,i] = Optim.minimizer(otm)
        value_trab[k,i] = -Optim.minimum(otm)
    end
    println(&quot;Iteration &quot;,k)
end
</code></pre>
<p>Podemos usar essas soluções e simular uma trajetória de salário para obter a escolha ótima de consumo e de poupança do agente. O código a seguir faz isso. Observe que, como em posts anteriores, eu deixei o primeiro elemento da matriz ser o último período do agente, então aqui eu preciso plotar e simular tudo de trás pra frente:</p>
<pre><code>start = 2
wage = rand(d,65)

cons = zeros(85)
asset = zeros(85)

asset[85] = start

for k in 65:-1:1
    cons_foo =  LinearInterpolation(w,choice_trab[k,:], extrapolation_bc = Line())
    cons[k+20] = cons_foo(asset[k+20])
    asset[k+19] = (1+r)*asset[k+20] - cons[k+20] + wage[k]
end

for k in 20:-1:2
    cons_foo =  LinearInterpolation(w,choice_ret[k,:], extrapolation_bc = Line()) #also depends on the convergence of the previous program
    cons[k] = cons_foo(asset[k])
    asset[k-1] = (1+r)*asset[k] - cons[k] + s
end

cons[1] = asset[1]

rett = zeros(20)
fill!(rett,s)
income = [wage[65:-1:1]; rett]

plot(asset[85:-1:1], lab = &quot;Assets&quot;, xlab = &quot;Tempo&quot;,legend = :topleft)
plot!(cons[85:-1:1], lab = &quot;Consumption&quot;)
plot!(income[1:85], lab = &quot;Income&quot;)
vline!([66],lab = &quot;Aposentadoria&quot;, lw = 2)</code></pre>
<p>Obtemos a seguinte imagem:</p>
<div class="figure">
<img src="/post/prev/exemplo.png" />

</div>
<p>Várias coisas são interessantes nessa imagem e mostram como programação dinâmica formaliza a nossa intuição econômica:</p>
<ol style="list-style-type: decimal">
<li><p>O agente escolhe um nível de consumo que varia muito pouco ao longo da vida dele, apesar das largas variações na renda. Milton Friedman e Franco Modigliani são os “pais” dessa ideia, a hipótese de renda permanente</p></li>
<li><p>Como consequência direta de (1), o valor dos ativos do agente varia muito mais do que o consumo</p></li>
<li><p>Também como consequência de (1), o agente poupa durante a vida de trabalho dele e despoupa na aposentadoria. Veja a inflexão dos ativos exatamente onde passa a linha de aposentadoria.</p></li>
</ol>
<p>Agora, podemos usar esse mesmo programa para nos perguntar como mudanças no esquema previdenciário afetam a decisão do agente. Por exemplo, o que acontece se eu mudar o valor que ele recebe aposentado para a média do que ele recebe na vida (5)? E para um valor maior, como 7? Nós vamos deixar o salário fixo em cada uma dessas simulações, ou seja, <em>usaremos exatamente os mesmos valores sorteados de salários que foram usados para gerar a imagem acima</em>. Assim, nós isolaremos o efeito de termos mudado apenas o valor pago na aposentadoria. Primeiro, como o consumo evolui para cada um dos casos:</p>
<div class="figure">
<img src="/post/prev/cons.png" />

</div>
<p>Veja que até os 20 anos o consumo não é muito diferente entre os 3 processos. No processo em que <span class="math inline">\(s=7\)</span>, o que acontece é que o consumo <em>aumenta</em> depois da aposentadoria. Isso é uma consequência de nós impedirmos endividamento e termos colocado uma aposentadoria muito acima da média do salário ganho pelo agente. Veja que, em geral, o consumo durante a vida toda é maior quanto maior for a aposentadoria. Vamos ver os ativos:<br />
<img src="/post/prev/assets.png" /></p>
<p>Aqui a diferença entre os diferentes valores poupados aparece claramente. Veja que um agente que espera uma aposentadoria baixa poupa muito mais que um agente que espera uma aposentadoria na média que ele recebia durante o empregado. Veja que isso tem implicações diretas em desenvolvimento, por exemplo, onde uma poupança maior está associado a mais capital e mais produto no estado estacionário (como no modelo de Solow) ou pode servir para financiar investimento em capital humano.</p>
<p>Outra maneira de vizualizar a mesma ideia é ver o consumo ótimo para cada nível de riqueza para cada um dos problemas. Eu escolhi um ponto arbitrário (a décima entrada em cada um deles, ou seja, faltando 10 anos para se aposentar) do tempo para comparar:</p>
<div class="figure">
<img src="/post/prev/otm_pol_comparada.png" />

</div>
<p>Veja que para valores maiores de <span class="math inline">\(s\)</span>, maior o nível de consumo dado a mesma riqueza. Veja que aqui o consumo ótimo depende da data que estamos olhando, ao contrário do problema em tempo infinito. Mas de forma geral as funções não mudam muito, e a imagem acima é bem representativa de se fossemos olhar período por período.</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=%2f2019%2f03%2f06%2faplicando-programa%25C3%25A7%25C3%25A3o-din%25C3%25A2mica-a-reforma-da-previd%25C3%25AAncia%2f - Aplicando%20Programa%c3%a7%c3%a3o%20Din%c3%a2mica%20a%20Reforma%20da%20Previd%c3%aancia "><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://github.com/danmrc/azul/tree/master/C%C3%B3digos">
        github
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> Daniel Coutinho e Pedro Cavalcante
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
</footer>

        </section>

        <script src="/js/jquery-3.3.1.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123754589-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
