<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programação on AZUL</title>
    <link>https://azul.netlify.app/tags/programa%C3%A7%C3%A3o/</link>
    <description>Recent content in Programação on AZUL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <copyright>Copyright © 2008–2020, Pedro Cavalcante &amp; Daniel Coutinho; all rights reserved.</copyright>
    <lastBuildDate>Thu, 10 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://azul.netlify.app/tags/programa%C3%A7%C3%A3o/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>{tidyverse}, Simulações e Processamento de Séries Temporais</title>
      <link>https://azul.netlify.app/2020/12/10/impureza-e-contexto-storch/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://azul.netlify.app/2020/12/10/impureza-e-contexto-storch/</guid>
      <description>Só para deixar tudo bem claro quanto ao que eu quero dizer quando falo em uma função impura: se fornecida os mesmos argumentos devolverá o mesmo resultado. É simples construir alguns exemplos.
foo1 &amp;lt;- function(x) {lubridate::now() + lubridate::dseconds(x + sample(-10:10, size = 1))} foo1(1)## [1] &#34;2020-12-11 07:03:25 -03&#34;foo1(1)## [1] &#34;2020-12-11 07:03:22 -03&#34;foo1(1)## [1] &#34;2020-12-11 07:03:40 -03&#34;Funções impuras também podem assim ser porque desencadeiam efeitos colaterais, como por exemplo escrever algum arquivo na memória.</description>
    </item>
    
  </channel>
</rss>
