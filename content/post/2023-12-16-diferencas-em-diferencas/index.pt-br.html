---
title: Viés em Diferenças em Diferenças
author: Daniel Coutinho
date: '2023-12-16'
slug: diferencas-em-diferencas
categories:
  - Econometria
tags:
  - Econometria
  - Diferenças em Diferenças
images: []
authors: ["danielc"]
output:
  blogdown::html_page:
    pandoc_args: 
      [
      "--lua-filter=../script_number_and_braces.lua"
      ]
draft: true
---



<p>Sim, eu nunca achei que eu ia chegar a isso. Mas cá estamos: um post sobre viés em diferenças em diferenças. Esse é um tópico relativamente falado em econometria e com uns exemplos legais, então eu decidi fazer esse post.</p>
<p>Sempre que a gente tem dados em painel, a reação pavloviana é dizer “efeitos fixos”. A ideia é que efeitos fixos capturam a heterogenidade não observada e isso potencialmente resolve problemas de viés de seleção.</p>
<p>O problema é quando nem todo mundo é tratado ao mesmo tempo. Curiosamente, o efeito fixo usual não funciona nesse caso - ou seja, o estimador é viesado. Mas a solução é extremamente simples e nos lembra que nem sempre o estimador usual funciona, mas uma pequena variação pode funcionar.</p>
<p>Se você precisa de um exemplo de tratamento que não é todo mundo ao mesmo tempo, talvez o melhor exemplo seja vacinação de covid: primeiro, os mais idosos foram vacinados e os mais jovens foram vacinados meses depois.</p>
<p>Para entender o problema, a gente vai fazer simulações - previsivelmente. A gente vai usar a linguagem de <em>potential outcome</em> aqui e então seja a variável de tratado ou não <span class="math inline">\(D\)</span>, o resultado se for tratado <span class="math inline">\(Y(1)\)</span> e se não for tratado <span class="math inline">\(Y(0)\)</span> e a gente observa:</p>
<p><span class="math display">\[
Y = DY(1) + (1-D)Y(0)
\]</span></p>
<p>O efeito de tratamento é <span class="math inline">\(Y(1) - Y(0)\)</span> e a gente só observa <span class="math inline">\(Y\)</span>. Como a gente está simulando, a gente pode salvar o efeito do tratamento salvando <span class="math inline">\(Y(1)\)</span> e <span class="math inline">\(Y(0)\)</span>. Dos muitos efeitos de tratamento possíveis, diferenças em diferenças recupera o efeito de tratamento sobre os tratados.</p>
<p>A gente vai usar o R pra aproveitar o pacote plm:</p>
<p>Eu nunca tinha feito nenhuma simulação gerando dados em painel - mentira, eu fiz <em>uma vez</em> na graduação, então não conta. Eu pensei bastante em como estruturar isso e achei melhor quebrar em uma função que gera dados pra um indíviduo e uma função que gera o painel a partir dessa função. Primeiro, a função que gera dados pra um indivíduo. A função vai ter vários inputs: um <code>id</code>, que diz qual o número que identifica o indvíduo; <code>t</code> me diz quantos períodos eu observo; <code>common shock</code> é só um choque em comum pra todos os indvíduos na hora que eu gerar o painel, e que vai ser responsabilidade do efeito fixo de tempo de remover; <code>cohort</code> é a coisa crítica aqui e me diz <em>quando</em> o indivíduo vai ser tratado <em>se</em> ele for tratado; <code>treat_effect</code> é o tamanho do efeito de tratamento, que é o que nos interessa; <code>thres</code> requer um pouquinho mais de explicação. A gente vai adotar o seguinte esquema: se uma variável aleatória <span class="math inline">\(u\)</span> estiver acima de <code>thres</code>, a unidade é tratada; senão, a unidade não é tratada. A gente assume que <span class="math inline">\(u\)</span> não é observado:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">one_indv &lt;- function(id,t,common_shock,cohort,treat_effect,thres){
  if(cohort &gt; t){
    stop("Cohort higher than number of periods")
  }
  
  if(cohort == 0){
    cohort &lt;- t + 1
  }
  
  u &lt;- rnorm(1)
  
  treat &lt;- u &gt; thres
  
  y0 &lt;- common_shock + rep(u,t+1) + rnorm(t+1)
  y1 &lt;- rep(treat_effect,t+1) + rep(u,t+1) + rnorm(t+1) + common_shock
  
  time_grid &lt;- 0:t
  treated &lt;- (time_grid &gt;= cohort)*treat
  y &lt;- y0*(1-treated) + y1*treated
  
  dataframe &lt;- data.frame("id" = rep(id,t+1), "T" = time_grid, "D" = treated, "Y" = y, "Y0" = y0, "Y1" = y1)
  
  return(dataframe)
  
}</code></pre>
<p>Da maneira que o código está escrito, tem duas maneiras de não ser tratado: ou a sua <code>cohort</code> é zero ou a sua variável <span class="math inline">\(u\)</span> está abaixo do limiar. Eu vou escrever a função que gera o painel de maneira que ninguém nunca tem <code>cohort = 0</code>:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">panel1 &lt;- function(t,n,thres,treat_effect){
  
  v &lt;- rnorm(t+1)
  cohort &lt;- sample(1:t,n,replace = TRUE)
  panel_list &lt;- map(1:n,\(x)one_indv(x,t,v,cohort[x],1,thres))
  panel &lt;- do.call(rbind,panel_list)
  panel &lt;- as.data.frame(panel)
  
  return(panel)
  
}</code></pre>
<p>Da maneira que painel1 está escrito, todo mundo tem o mesmo <code>thres</code> e o mesmo efeito de tratamento. Isso não é ruim porque tira uma variação e permite a gente focar na variação de ter vários períodos. Vamos olhar o que acontece quando a gente roda isso uma vez, com 4 períodos e 500 indivíduos:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">data &lt;- panel1(3,500,0,1)
mod &lt;- plm(Y ~ D,data = data, index = c("id","T"))
data_treated &lt;- data %&gt;% group_by(id) %&gt;% filter(any(D == 1))
ATT &lt;- data_treated$Y1 - data_treated$Y0</code></pre>
<p>O efeito de tratamento é a média da variável ATT, que é 0.9088279 e é bem perto do que a gente colocou no código. O efeito de tratamento estimado é 2.1627203, que é o dobro do valor verdadeiro.</p>
<p>Vamos fazer umas mil simulações pra ver o que acontece. Eu vou escrever uma função que me retorna o efeito de tratamento e o coeficiente estimado e a gente vai fazer um histograma disso:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">simul1 &lt;- function(t,n,thres,treat_effect){
  data &lt;- panel1(t,n,thres,treat_effect)
  mod &lt;- plm(Y ~ D,data = data, index = c("id","T"))
  data_treated &lt;- data %&gt;% group_by(id) %&gt;% filter(any(D == 1))
  ATT &lt;- data_treated$Y1 - data_treated$Y0
  
  return(c(coef(mod),mean(ATT)))
}

resul &lt;- map(1:1000,\(x)simul1(3,500,0,1))
resul &lt;- do.call(rbind,resul)

diff &lt;- resul[,1] - resul[,2]</code></pre>
<p>Vamos fazer um histograma disso:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">ggplot(data.frame(var = diff),aes(var)) + geom_histogram() + theme_light()</code></pre>
<pre ><code >## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="/post/2023-12-16-diferencas-em-diferencas/index.pt-br_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Tudo parece bem aqui: o histograma está centrado em zero e parece ter só uma pequena assimetria. O problema maior é quando a gente tem efeitos de tratamento que mudam conforme a data que o indivíduo é tratado. A gente vai alterar um pouquinho a função <code>painel1</code> pra permitir diferentes efeitos de tratamento em cada período e diferentes probabilidades de ser alocado a cada período (é pra isso que a gente tem um novo argumento na função, <code>prob</code>):</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">panel2 &lt;- function(t,n,thres,treat_effect,prob){
  
  v &lt;- rnorm(t+1)
  cohort &lt;- sample(0:t,n,replace = TRUE,prob = prob)
  treat_effect_n &lt;- treat_effect[cohort+1]
  panel_list &lt;- map(1:n,\(x)one_indv(x,t,v,cohort[x],treat_effect_n[x],thres))
  panel &lt;- do.call(rbind,panel_list)
  panel &lt;- as.data.frame(panel)
  
  return(panel)
  
}</code></pre>
<p>Vamos fazer igualzinho acima:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">treatment_effects &lt;- c(0,1,0.7,0.5)
data &lt;- panel2(3,5000,0,treatment_effects,c(0,1/4,1/4,3/8))
mod &lt;- plm(Y ~ D,data = data, index = c("id","T"))
data_treated &lt;- data %&gt;% group_by(id) %&gt;% filter(any(D == 1))
ATT &lt;- mean(data_treated$Y1 - data_treated$Y0)</code></pre>
<p>O efeito de tratamento é a média da variável ATT, que é 0.7102029, enquanto o efeito de tratamento estimado é 1.3398041. Vamos criar outra função que faz a simulação:</p>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">simul2 &lt;- function(t,n,thres,treat_effect,prob){
  
  data &lt;- panel2(t,n,thres,treat_effect,prob)
  mod &lt;- plm(Y ~ D,data = data, index = c("id","T"))
  data_treated &lt;- data %&gt;% group_by(id) %&gt;% filter(any(D == 1))
  ATT &lt;- mean(data_treated$Y1 - data_treated$Y0)
  
  return(c(coef(mod),mean(ATT)))
  
}</code></pre>
<pre class = "line-numbers"><code class="language-r match-braces rainbow-braces">treatment_effects &lt;- c(0,1,0.7,0.5)

resul2 &lt;- map(1:1000,\(x)simul2(3,500,0,treatment_effects,c(0,1/4,1/4,3/8)))
resul2 &lt;- do.call(rbind,resul2)

diff2 &lt;- resul2[,1] - resul2[,2]

ggplot(data.frame(var = diff2),aes(var)) + geom_histogram() + theme_light()</code></pre>
<pre ><code >## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="/post/2023-12-16-diferencas-em-diferencas/index.pt-br_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
