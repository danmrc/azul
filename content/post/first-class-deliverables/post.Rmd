---
title: Todos os Entregáveis Devem Ser de Primeira-Classe
author: Pedro Cavalcante
date: '2022-12-14'
slug: first-class-deliverables
categories:
  - Handwavy
tags:
  - Engenharia de Software
  - Handwavy
images: []
authors: ["pedrocava"]
output:
  blogdown::html_page:
    pandoc_args: 
      [
      "--lua-filter=../script_number_and_braces.lua"
      ]
---

Data Science em um ambiente de negócios é, em última instância, produzir software e seus entregáveis darão meia volta para te morder na bunda caso esqueça. É apenas um fato incortável do seu ecossistema profissional e o quanto antes fizer as pazes com isso, melhor.

_Automatização_ é um gradiente e um script que precisa do seu precioso `ctrl + Enter` não está perto de qualquer extremo em particular. Uma regra de bolso razoável: se precisa dos seus dedinhos no teclado, tem algo obviamente automatizável na sua frente. Digo mais, o esforço gasto nisso se paga.

"Automatizar", claro, não tem um significado limpo. Pode ser questão de agendar um cronjob no seu sistema, definir um evento no seu `EventWhatever` ou `CloudStuffo`, uma tarefa nova no seu framwork de gestão de workflow (aka. [`airflow`](https://airflow.apache.org/), [`prefect`](https://www.prefect.io/), [`dagster`](https://dagster.io/), etc...), implementar um endpoint novo na sua aplicação construída em cima de um FaaS. De qualquer jeito isso demanda horas humanas domando a máquina.

Não, o `databricks` não vai resolver isso para você:

```{R echo = FALSE}
tweetrmd::include_tweet(
  "https://twitter.com/ryxcommar/status/1585099532886372352")

```

Esse tempo de engenharia pode ser encarado como _gasto de capital_. O _gasto operacional_ em algum ponto no futuro é uma variável aleatória e o que o CAPex de hoje faz é aumentar a média e diminuir a variância. Se for gasto nas coisas importantes, os efeitos são enormes. Esse take é totalmente baseado nas anedotas que escuto de conhecidos na indústria então tome com a seriedade que ele merece: esses efeitos são _vastamente_ subestimados.

É a única conclusão que consigar tirar do quão comum é o relato de que tem alguma(s) rotina(s) crítica(s) para entrega de valor de negócio que depende(m) de alguém manualmente rodar um script. Se isso acontece no seu navio pare e pense profundamente no jogo que está sendo jogado. O que acontece quando fulaninho tirar férias, ou pegar covid? O que acontece quando algum stakeholder pedir uma alteração importante e ainda poder comparar as duas versões por algum tempo? E quando é preciso fazer um exercício contrafactual? Demissão? Churn de funcionário totalmente esperado?

Desculpe, vou cometer uma citação de [Wikipedia](https://en.wikipedia.org/wiki/First-class_citizen):

> In programming language design, a first-class citizen (also type, object, entity, or value) in a given programming language is an entity which supports all the operations generally available to other entities. These operations typically include being passed as an argument, returned from a function, and assigned to a variable.

Existe um mundo melhor, um mundo onde (quase) todo entregável *é um cidadão de primeira classe*. A computação de uma métrica (ou regra de negócio, gráfico, sumário, relatório, etc) deve, em geral, ser resultado de alguma _função_ que recebe argumentos pertinentes e retorna o resultado esperado. O código típico produzido no dia a dia deveria depender de ferramentas internas que criam um conjunto de convenções pertinentes _ao negócio_. Você deveria usar sua(s) lib(s) interna(s) tanto quanto usa o `dplyr` ou o `pandas`.

Você já ouviu esse diálogo:

>  _Fulano, como que calcula se o usuário tá funblingado mesmo_?
> 
> _Não sei, mas o código tá em algum lugar do_ `pastamaior/pastamenor/pasta_qualquer_coisa/script32.py`

O código para computar isso agora vai precisar ser compreendido para ser replicado em outro arquivo com algumas trocas. Quem copiou perdeu neurônios, não existe mais fonte de verdade na codebase, ninguém sabe o que testar e mesmo que saibam, não _tem_ como testar de maneira automática porque ninguém em sã consciência vai tentar testar uma aplicação usando o texto do código. Se o entregável for (i) retornado por alguma função, (ii) atribuível a um objeto e (iii) passado como argumento (_ie_ de primeira classe), então todas essas propriedades vêm de graça.

Em linguagens moderna de alto-nível como python ou R, se uma função retorna algo, então esse algo é de primeira classe e pode ser tratado de acordo. É de bom tom criar um _predicado_, uma função que retorna verdadeiro/falso, para testar se um objeto arbitrário representa uma certa entidade de negócio como uma métrica, gráfico ou relatório.

```{R eval = FALSE}

some_data <- firmalib::compute_metric(
  metric = "support_calls",
  window = "weekly")

firmalib::is_metric(some_data) # TRUE

tibble::tibble(
  A = 1,
  B = 2) %>%
  firmalib::is_metric() # FALSE

some_plot <- firmalib::plot(
  name = "that_one_graph_about_stuff",
  start_date = lubridate::dmy("01-01-2022"),
  end_date = lubridate::today())

firmalib::is_firma_plot(some_plot) # TRUE

```

Nas linguagens comuns do ecossistema de data science, funções são cidadãs de primeira classe. Nada está te impedindo de criar uma função que retorna uma estrutura de dados contendo funções responsáveis pela computação de cada entregável, e outra que escolhe dinamicamente qual métrica computar.

```{R eval = FALSE}
compute_metric <- function(metric, window) {
  
  firmalib::metric_implementations() %>%
    purrr::pluck(metric) ->
    metric_fn
  
  metric_fn(window)
  
}

metric_implementations <- function() {
  
  list(
    "support_calls" = firmalib::support_calls_impl,
    "total_profit" = firmalib::total_profit_impl)
  
}

support_calls_impl <- function(window) {
  
  ...
  
}
```

Na vida real você vai precisar de mais liberdade de parametrização, e usar algo como `kargs` (python) ou `...` (R). Você talvez queira alguma forma de validação (infelizmente vai ter que ser em tempo de execução) de que ninguém está pedindo uma métrica que não foi definida. Consegue ver como implementar nesse pequeno exemplo? Seria também interessante alguma forma de metadado no resultado para carimbar o resultado com qual entidade de negócio ele é.

_Exercício Inútil_: como contornar a atribuição dentro da implementação de `compute_metric` usando [currying](https://stackoverflow.com/questions/36314/what-is-currying)?

Relatórios são uma exceção nítida aqui porque são... arquivos no disco. Dito isso, que tal tornar todos os gráficos usados no relatórios cidadãos de primeira classe? E que tal ter uma abstração para renderizar relatórios, algo como `firmalib::render_report("some_report")` que tem como efeito colaterável renderizar o relatório e retorna o endereço dele no disco? Com algumas convenções sobre onde esse relatório pode ser escrito e estrutura de pastas, pelo menos isso pode ser testado.

Com essas ideias, um cronjob e um pouquinho de encanamento dá para cortar horas de trabalho mensal, dor de cabeça, ganhar em testabilidade e confiabilidade. Trate seus entregáveis com carinho.