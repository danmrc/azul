---
title: Por que usar o Julia?
author: Daniel Coutinho
date: '2018-09-13'
slug: por-que-usar-o-julia
categories:
  - Computação
tags:
  - Profiling
  - Julia
  - R
authors: ["danielc"]
draft: true
katex: true
---



<p>Eu já fiz alguns posts em que eu usava a linguagem de programação Julia. O Julia é relativamente novo: o projeto começou em 2009 e a versão 1.0 foi lançada esse ano. Apesar disso, ela já é um relativamente conhecida. O Julia promete ter uma sintaxe clara e ser mais rápido do que linguagens como o Matlab e o R.</p>
<p>Eu sempre tomei como certo a afirmação do Julia de que ele era mais rápido que os concorrentes. Este post vai colocar a prova a velocidade do Julia: será que ele realmente é mais rápido? O quão mais rápido? Para isso, eu vou comparar o Julia com o R. Ambos são open source. O R é extremamente popular e usado amplamente em diversas áreas. Eu não vou comparar o Matlab com o Julia: o matlab é um programa que tem que ser comprado (e não é barato), e portanto comparar os dois não vai ser tão informativo. Mal comparando, ninguém ficaria muto feliz de ser informado que ir de jatinho é mais rápido que ir de ônibus: não é surpreendente, mas ei, eu não tenho dinheiro para alugar um jatinho.</p>
<p>Eu vou fazer alguns testes em um Dell Vostro 2012, Windows 10, 6 GB de Ram e processador i5. Eu vou rodar o R direto do RStudio e o Julia do Atom. Eu deixei apenas o RStudio e o Atom abertos. Vamos a bateria de testes:</p>
<div id="mqo" class="section level2">
<h2>1.MQO</h2>
<p>O estimador de MQO é um ótimo teste. Não só é muito usado, como ele trabalha com matrizes, faz uma inversa de matriz, que são operações muito comuns em estatística. O teste para comparar os dois vai ser bem simples:</p>
<ol style="list-style-type: decimal">
<li><p>Eu vou escrever uma função que faz o estimador de MQO “no braço”, ou seja, cospe <span class="math inline">\((X&#39;X)^{-1}X&#39;y\)</span></p></li>
<li><p>Vou criar uma outra função que faz um for e replica 1000 vezes gerar 5 variáveis com 100 observações cada uma e estima o estimador de MQO usando a minha função</p></li>
<li><p>Vou repetir chamar essa função umas 100 vezes e salvar não o conteúdo dela, mas sim o resultado do timing</p></li>
</ol>
<p>E aqui estão os códigos para o <a href="https://github.com/danmrc/azul/blob/master/C%C3%B3digos/tempo_1.R">R</a> e para o <a href="https://github.com/danmrc/azul/blob/master/C%C3%B3digos/tempo_1.jl">Julia</a>.</p>
<p>E os tempos, em segundos, são:</p>
<table>
<thead>
<tr class="header">
<th>R</th>
<th>Julia</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.1213</td>
<td>0.0246</td>
</tr>
</tbody>
</table>
<p>O Julia é muito mais rápido. Mas uma pergunta justa é se usando o <code>lm(y ~x)</code> nativo do R nós não obtemos resultados melhores. Esse é o objetivo do <code>func2</code> no arquivo acima. O resultado da mesma simulação usando o <code>lm</code> são estúpidos <span class="math inline">\(0.9558\)</span>.</p>
<p>Julia 1, R 0.</p>
</div>
<div id="otimizacao" class="section level2">
<h2>2. Otimização</h2>
<p>É muito comum precisar encontrar o máximo ou mínimo de uma função. Vamos testar isso comparando o <code>optim</code> do próprio R e o pacote do Julia <strong>optim</strong>, que foi escrito em Julia.</p>
</div>
<div id="uma-simulacao-pequena" class="section level2">
<h2>3. Uma simulação pequena</h2>
<p>Vamos ver como cada uma das linguagens se comporta com uma simulação pequena. Para variar um pouco, eu vou escrever uma função que calcula o desvio padrão numericamente a partir de uma amostra <span class="math inline">\(x\)</span> da seguinte forma:</p>
<ul>
<li>Tire uma amostra aleatória de <span class="math inline">\(X\)</span>, permitindo repetições. Esta amostra tem o tamanho <span class="math inline">\(n\)</span>, que você quiser.</li>
<li>Calcule a média desta amostra aleatória e coloque isso em um vetor <span class="math inline">\(b\)</span></li>
<li>Calcule o desvio padrão de <span class="math inline">\(b\)</span>. Ele deve ser igual a <span class="math inline">\(\frac{\sigma}{\sqrt{n}}\)</span>, onde <span class="math inline">\(\sigma\)</span> é o desvio padrão da variável <span class="math inline">\(x\)</span>.</li>
</ul>
<p>Este procedimento é conhecido como <em>bootstrap</em>. Apenas para garantir que o procedimento faz sentido, eu deixo abaixo a versão do R. Vamos fazer uma amostra de 100 observações distribuídas <span class="math inline">\(N(0,1)\)</span>. A nossa reamostragem vai ter 100 observações também.</p>
<pre class="r"><code>amostra &lt;- rnorm(1000)

boot &lt;- rep(0,10000)

for(i in 1:10000){
  amostra_boot &lt;- sample(amostra,size = 500, replace = T)
  boot[i] &lt;- mean(amostra_boot)
}

tabela &lt;- cbind(sd(boot),sd(amostra)/sqrt(500))
knitr::kable(tabela, col.names = c(&quot;Desvio padrão bootstrap&quot;,&quot;Desvio padrão analítico&quot;))</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">Desvio padrão bootstrap</th>
<th align="right">Desvio padrão analítico</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0.0439302</td>
<td align="right">0.0441283</td>
</tr>
</tbody>
</table>
<p>Veja que usaremos este mesmo código no nosso teste. Ele basicamente testa o quão bom é cada linguagem ao rodarmos um <em>loop</em>.</p>
</div>
<div id="por-que-nao-usar-o-julia" class="section level2">
<h2>Por que não usar o Julia?</h2>
<p>Dado todos os elogios ao Julia até aqui, talvez seja uma boa hora de dizer quais as coisas ruins do Julia. A primeira é que não há tantos pacotes quanto o R, e nem temos uma IDE tão boa quanto o RStudio (apesar do Atom ser bastante competente). Por exemplo, não estamos nem perto de integrar arquivos markdown com código em Julia direto no Atom. Como o Julia é uma linguagem muito nova, as mudanças entre versões anteriores a 1.0 eram brutais - espero que a linguagem se estabilize a partir de agora. Um outro “problema” é que a primeira vez que você roda um código, o Julia é lento. Isso não é um <em>bug</em>: o Julia é uma linguagem compila, então a primeira vez que você roda um código ele vai ser mais lento que linguagens interpretadas como o Python e o R. Entretanto, nas vezes seguintes, ele vai ser muito mais rápido, como os testes acima mostram.</p>
</div>
