---
title: Por que usar o Julia?
author: Daniel Coutinho
date: '2018-09-13'
slug: por-que-usar-o-julia
categories:
  - Computação
tags:
  - Profiling
  - Julia
  - R
authors: ["danielc"]
draft: true
katex: true
---

Eu já fiz alguns posts em que eu usava a linguagem de programação Julia. O Julia é relativamente novo: o projeto começou em 2009 e a versão 1.0 foi lançada esse ano. Apesar disso, ela já é um relativamente conhecida. O Julia promete ter uma sintaxe clara e ser mais rápido do que linguagens como o Matlab e o R. 

Eu sempre tomei como certo a afirmação do Julia de que ele era mais rápido que os concorrentes. Este post vai colocar a prova a velocidade do Julia: será que ele realmente é mais rápido? O quão mais rápido? Para isso, eu vou comparar o Julia com o R. Ambos são open source. O R é extremamente popular e usado amplamente em diversas áreas. Eu não vou comparar o Matlab com o Julia: o matlab é um programa que tem que ser comprado (e não é barato), e portanto comparar os dois não vai ser tão informativo. Mal comparando, ninguém ficaria muto feliz de ser informado que ir de jatinho é mais rápido que ir de ônibus: não é surpreendente, mas ei, eu não tenho dinheiro para alugar um jatinho. 

Eu vou fazer alguns testes em um Dell Vostro 2012, Windows 10, 6 GB de Ram e processador i5. Eu vou rodar o R direto do RStudio e o Julia do Atom. Eu deixei apenas o RStudio e o Atom abertos. Vamos a bateria de testes:

##1.MQO

O estimador de MQO é um ótimo teste. Não só é muito usado, como ele trabalha com matrizes, faz uma inversa de matriz, que são operações muito comuns em estatística. O teste para comparar os dois vai ser bem simples:

1. Eu vou escrever uma função que faz o estimador de MQO "no braço", ou seja, cospe $(X'X)^{-1}X'y$

2. Vou criar uma outra função que faz um for e replica 1000 vezes gerar 5 variáveis com 100 observações cada uma e estima o estimador de MQO usando a minha função

3. Vou repetir chamar essa função umas 100 vezes e salvar não o conteúdo dela, mas sim o resultado do timing

E aqui estão os códigos para o [R](https://github.com/danmrc/azul/blob/master/C%C3%B3digos/tempo_1.R) e para o [Julia](https://github.com/danmrc/azul/blob/master/C%C3%B3digos/tempo_1.jl).

E os tempos, em segundos, são:

 R    | Julia
------|------
0.1213|0.0246

O Julia é muito mais rápido. Mas uma pergunta justa é se usando o `lm(y ~x)` nativo do R nós não obtemos resultados melhores. Esse é o objetivo do `func2` no arquivo acima. O resultado da mesma simulação usando o `lm` são estúpidos $0.9558$. 

Julia 1, R 0.

##2. Otimização

É muito comum precisar encontrar o máximo ou mínimo de uma função. Vamos testar isso comparando o `optim` do próprio R e o pacote do Julia **optim**, que foi escrito em Julia. 

##3. Uma simulação pequena

Vamos ver como cada uma das linguagens se comporta com uma simulação pequena. Para variar um pouco, eu vou escrever uma função que calcula o desvio padrão numericamente a partir de uma amostra $x$ da seguinte forma:

* Tire uma amostra aleatória de $X$, permitindo repetições. Esta amostra tem o tamanho $n$,  que você quiser. 
* Calcule a média desta amostra aleatória e coloque isso em um vetor $b$
* Calcule o desvio padrão de $b$. Ele deve ser igual a $\frac{\sigma}{\sqrt{n}}$, onde $\sigma$ é o desvio padrão da variável $x$. 

Este procedimento é conhecido como _bootstrap_. Apenas para garantir que o procedimento faz sentido, eu deixo abaixo a versão do R. Vamos fazer uma amostra de 100 observações distribuídas $N(0,1)$. A nossa reamostragem vai ter 100 observações também. 

```{r}

amostra <- rnorm(1000)

boot <- rep(0,10000)

for(i in 1:10000){
  amostra_boot <- sample(amostra,size = 500, replace = T)
  boot[i] <- mean(amostra_boot)
}

tabela <- cbind(sd(boot),sd(amostra)/sqrt(500))
knitr::kable(tabela, col.names = c("Desvio padrão bootstrap","Desvio padrão analítico"))
```

Veja que usaremos este mesmo código no nosso teste. Ele basicamente testa o quão bom é cada linguagem ao rodarmos um _loop_.  

## Por que não usar o Julia?

Dado todos os elogios ao Julia até aqui, talvez seja uma boa hora de dizer quais as coisas ruins do Julia. A primeira é que não há tantos pacotes quanto o R, e nem temos uma IDE tão boa quanto o RStudio (apesar do Atom ser bastante competente). Por exemplo, não estamos nem perto de integrar arquivos markdown com código em Julia direto no Atom. 
Como o Julia é uma linguagem muito nova, as mudanças entre versões anteriores a 1.0 eram brutais - espero que a linguagem se estabilize a partir de agora. Um outro "problema" é que a primeira vez que você roda um código, o Julia é lento. Isso não é um _bug_: o Julia é uma linguagem compila, então a primeira vez que você roda um código ele vai ser mais lento que linguagens interpretadas como o Python e o R. Entretanto, nas vezes seguintes, ele vai ser muito mais rápido, como os testes acima mostram. 



